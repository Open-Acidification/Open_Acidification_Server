import math
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_http_methods
from django.http import HttpResponse, JsonResponse
from django.shortcuts import render
from rest_framework.parsers import JSONParser
from time_series.models import TimeSeries
from time_series.serializers import TimeSeriesSerializer


@csrf_exempt
@require_http_methods(["GET"])
def time_series_list(request, ts_type=''):
    ts_type = sanitize_ts_type(ts_type)

    # Return a list of all time series of the specified parameter
    if ts_type == 'P':
        series = TimeSeries.objects.get(ts_type='P')
    elif ts_type == 'T':
        series = TimeSeries.objects.get(ts_type='T')
    else:
        series = TimeSeries.objects.all()

    ts_serializer = TimeSeriesSerializer(series, many=True)
    return JsonResponse(ts_serializer.data, safe=False)

@csrf_exempt
@require_http_methods(["GET", "POST"])
def time_series_save(request):
    # Save the provided time series
    if request.method == 'POST':
        data = JSONParser().parse(request)
        ts_serializer = TimeSeriesSerializer(data=data)
        if ts_serializer.is_valid():
            ts_serializer.save()
            return JsonResponse(ts_serializer.data, status=201)
        return JsonResponse(ts_serializer.errors, status=400)
    
    # Return a list of all time series of the specified type (GET)
    return time_series_list(request)

@csrf_exempt
@require_http_methods(["GET", "PUT", "DELETE"])
def time_series_detail(request, time_series_id):
    # First, check if specified time series exists
    try:
        series = TimeSeries.objects.get(id=time_series_id)
    except TimeSeries.DoesNotExist:
        return HttpResponse(status=404)

    # Update the specified time series
    if request.method == 'PUT':
        data = JSONParser().parse(request)
        ts_serializer = TimeSeriesSerializer(series, data=data)
        if ts_serializer.is_valid():
            ts_serializer.save()
            return JsonResponse(ts_serializer.data)
        return JsonResponse(ts_serializer.errors, status=400)

    # Delete the specified time series
    if request.method == 'DELETE':
        series.delete()
        return HttpResponse(status=204)

    # Read the specified time series (GET)
    ts_serializer = TimeSeriesSerializer(series)
    return JsonResponse(ts_serializer.data)

@csrf_exempt
@require_http_methods(["GET", "POST"])
def time_series_generate_hold(request):

    hold_at = request.GET.get('at', default=8)

    # Save a time series representing the hold function of the specified parameters
    if request.method == 'POST':
        data = {'name': request.POST.get('name', default='Unnamed'), \
            'value': [float(hold_at)], 'time': [0], 'interval': 0, \
            'notes' : "Generated by hold function with value "+str(hold_at)}

        ts_serializer = TimeSeriesSerializer(data=data)
        if ts_serializer.is_valid():
            ts_serializer.save()
            return JsonResponse(ts_serializer.data, status=201)
        return JsonResponse(ts_serializer.errors, status=400)

    # Return a time series representing the hold function of the specified parameters (GET)
    return JsonResponse({'value': [float(hold_at)], 'time': [0], 'interval': 0, \
        'description' : "Generated by hold function with value "+str(hold_at)})


@csrf_exempt
@require_http_methods(["GET", "POST"])
def time_series_generate_ramp(request):
    if request.method == 'POST':

        start = request.POST.get('start', default=7)
        end = request.POST.get('end', default=9)
        duration = request.POST.get('duration', default=600)

        data = {'name': request.POST.get('name', default='Unnamed'), \
            'value': [float(start), float(end)], 'time': [0, int(duration)], 'interval': 0, \
            'notes' : "Generated by ramp function with start value "+str(start)+ \
                ", end value "+str(end)+", and duration "+str(duration)}

        ts_serializer = TimeSeriesSerializer(data=data)
        if ts_serializer.is_valid():
            ts_serializer.save()
            return JsonResponse(ts_serializer.data, status=201)
        return JsonResponse(ts_serializer.errors, status=400)

    # GET
    start = request.GET.get('start', default=7)
    end = request.GET.get('end', default=9)
    duration = request.GET.get('duration', default=600)

    return JsonResponse({'value': [float(start), float(end)], 'time': [0, int(duration)], \
        'interval': 0, 'description' : "Generated by ramp function with start value "+ \
            str(start)+", end value "+str(end)+", and duration "+str(duration)})

@csrf_exempt
@require_http_methods(["GET", "POST"])
def time_series_generate_sine(request):
    if request.method == 'POST':

        frequency = request.POST.get('frequency', default=600)
        amplitude = request.POST.get('amplitude', default=1)
        offset_x = request.POST.get('offset_x', default=0)
        offset_y = request.POST.get('offset_y', default=8)

        value = [round(point_in_wave((1/10) * i, 1, amplitude, \
            offset_x, offset_y), 4) for i in range(0, 20)]

        time = [frequency/10 * i for i in range(0, 20)]

        data = {'name': request.POST.get('name', default='Unnamed'), \
            'value': value, 'time': time, 'interval': frequency*2.1, \
            'notes' : "Generated by sine function with frequency "+str(frequency)+ \
                ", amplitude "+str(amplitude)+", offset_x "+str(offset_x)+ \
                ", and offset_y "+str(offset_y)}

        ts_serializer = TimeSeriesSerializer(data=data)
        if ts_serializer.is_valid():
            ts_serializer.save()
            return JsonResponse(ts_serializer.data, status=201)
        return JsonResponse(ts_serializer.errors, status=400)

    # GET
    frequency = request.GET.get('frequency', default=600)
    amplitude = request.GET.get('amplitude', default=1)
    offset_x = request.GET.get('offset_x', default=0)
    offset_y = request.GET.get('offset_y', default=8)

    value = [round(point_in_wave((1/10) * i, 1, amplitude, offset_x, offset_y), 4) \
        for i in range(0, 20)]
    time = [frequency/10 * i for i in range(0, 20)]

    return JsonResponse({'value': value, 'time': time, 'interval': frequency*2.1, \
        'description' : "Generated by sine function with frequency "+ \
            str(frequency)+", amplitude "+str(amplitude)+", offset_x "+ \
            str(offset_x)+", and offset_y "+str(offset_y)})


def point_in_wave(point_x, frequency, amplitude, offset_x, offset_y):
    """Returns the specified point x in the wave of specified parameters."""
    return (math.sin((math.pi * point_x)/frequency + offset_x) * amplitude) + offset_y

def sanitize_ts_type(ts_type):
    # Make type case-insensitive
    ts_type = ts_type.lower()

    # Change type to character code
    if ts_type == 'ph':
        ts_type = 'P'
    elif ts_type == 'temp' or ts_type == "temperature":
        ts_type = 'T'
    else:
        ts_type = ''

    return ts_type
